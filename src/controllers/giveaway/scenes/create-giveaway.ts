import { Giveaway } from '@prisma/client';
import moment from 'moment-timezone';
import { Scenes } from 'telegraf';
import { prisma } from '../../..';
import { SCENES } from '../../../config';
import { errorReply } from '../../../utils';

export const createGwScene = new Scenes.WizardScene(
	SCENES.CREATE_GW,
	//@ts-ignore
	async ctx => {
		try {
			ctx.reply('üñä –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ –∫–∞–∫ —Ä–æ–∑—ã–≥—Ä—ã—à, –º–æ–∂–Ω–æ –ø—Ä–∏–ª–∞–≥–∞—Ç—å: —Ñ–æ—Ç–æ, –≤–∏–¥–µ–æ, GIF —Å —Ç–µ–∫—Å—Ç–æ–º –∏–ª–∏ –±–µ–∑');

			//@ts-ignore
			ctx.scene.state.locId = ctx.scene.session.state.locId as number;

			return ctx.wizard.next();
		} catch (error) {
			errorReply(ctx);
			console.error(error);
		}
	},
	async ctx => {
		try {
			//@ts-ignore
			ctx.scene.state.gw = {
				messageText: ctx.text,
				creatorId: ctx.session!.user!.id,
				locationId: ctx.scene.state.locId,
			} as Giveaway;

			ctx.reply('üéñ –ù–∞–ø–∏—à–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π.\nüëâ –ú–∞–∫—Å–∏–º—É–º: 100');
			return ctx.wizard.next();
		} catch (error) {
			errorReply(ctx);
			console.error(error);
		}
	},
	async ctx => {
		try {
			const winnerCount = parseInt(ctx.text!);
			if (!winnerCount || winnerCount > 100) return ctx.reply('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.');

			ctx.scene.state.gw.winnerCount = winnerCount;

			const gw = await prisma.giveaway.create({ data: { ...ctx.scene.state.gw, createdAt: moment(new Date()).tz('Europe/Moscow').toDate() } });

			ctx.reply('–†–æ–∑—ã–≥—Ä—ã—à —Å–æ–∑–¥–∞–Ω', { reply_markup: { inline_keyboard: [[{ text: '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å', callback_data: `edit_gw:${gw.id}` }]] } });
			return ctx.scene.leave();
		} catch (error) {
			errorReply(ctx);
			console.error(error);
		}
	}
);
